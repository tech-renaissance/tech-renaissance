在src/backend/cpu/cpu_create.cpp当中，实现以下几个函数。实现方式可参考Tensor类的工厂函数，但不可以直接调用Tensor类的工厂函数。然后编写测试样例tests/unit_tests/test_cpu_create.cpp。除此之外，不要新增任何文件。每个函数测试一次即可，不需要测试INT8的情况。如果inplace型函数的输入是空张量，则报错（throw TRException）。

| 函数形式                                                     | 支持张量类型                                                 | 行为                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Tensor full(const Shape& shape, float value, DType dtype = DType::FP32); | 可选FP32和INT8，但INT8现在不实现，报错（throw TRException）并标为TODO，就说currently unsupported | 创建一个值全为value的张量并返回                              |
| void full_inplace(Tensor& tensor_a, float value);            | 类型就是tensor_a的类型，不改变。但如果tensor_a是INT8，就先不实现，报错（throw TRException）并标为TODO，就说currently unsupported | 把张量a的元素全部填充为value                                 |
| Tensor randn(const Shape& shape, unsigned int seed = 0);     | 明确只支持FP32张量                                           | 创建一个FP32张量，用(0,1)正态分布的随机数填充                |
| void randn_inplace(Tensor& tensor_a, unsigned int seed = 0); | 明确只支持FP32张量，如果tensor_a是INT8，就报错（throw TRException），说这个函数只能用于FP32张量 | 用(0,1)正态分布的随机数填充tensor_a                          |
| Tensor uniform(const Shape& shape, float min_val = 0.0f, float max_val = 1.0f, unsigned int seed = 0); | 明确只支持FP32张量                                           | 创建一个FP32张量，用min_val和max_val之间的均匀分布随机数填充 |
| void uniform_inplace(Tensor& tensor_a, float min_val = 0.0f, float max_val = 1.0f, unsigned int seed = 0); | 明确只支持FP32张量，如果tensor_a是INT8，就报错（throw TRException），说这个函数只能用于FP32张量 | 用min_val和max_val之间的均匀分布随机数填充tensor_a           |
| Tensor randint(const Shape& shape, int low, int high, unsigned int seed = 0, DType dtype = DType::FP32); | 可选FP32和INT8，但INT8现在不实现，报错（throw TRException）并标为TODO，就说currently unsupported | 创建一个FP32张量，用low和high之间的随机整数填充（对于浮点数，所谓“随机整数”是指1.0f和2.0f这种，也就是整数转为浮点数或浮点数取round的结果） |
| void randint_inplace(Tensor& tensor_a, int low, int high, unsigned int seed = 0); | 类型就是tensor_a的类型，不改变。但如果tensor_a是INT8，就先不实现，报错（throw TRException）并标为TODO，就说currently unsupported | 用low和high之间的随机整数填充tensor_a（对于浮点数，所谓“随机整数”是指1.0f和2.0f这种，也就是整数转为浮点数或浮点数取round的结果） |
| Tensor randbool(const Shape& shape, float rate_of_zeros, unsigned int seed = 0, DType dtype = DType::FP32); | 可选FP32和INT8，但INT8现在不实现，报错（throw TRException）并标为TODO，就说currently unsupported | 创建一个FP32张量，用0.0f和1.0f填充，其中0.0f出现的概率等于rate_of_zeros（比如rate_of_zeros为0.4，则0.0f出现的概率就是40%） |
| void randbool_inplace(Tensor& tensor_a, float rate_of_zeros, unsigned int seed = 0); | 类型就是tensor_a的类型，不改变。但如果tensor_a是INT8，就先不实现，报错（throw TRException）并标为TODO，就说currently unsupported | 用0.0f和1.0f填充tensor_a，其中0.0f出现的概率等于rate_of_zeros（比如rate_of_zeros为0.4，则0.0f出现的概率就是40%） |